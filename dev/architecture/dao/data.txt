Plan 
- Introduction 
- Example app screens 
- Example app api 
- Create data access object 
- Create acceses 
- Create models 
- Use data access object 
- Tests 
- Implementation 
- Conclusion 
 
	Introduction 
Всем привет. Хочу рассказать как по моему мнению можно красиво, просто и мощно обеспечить доступ к локальной базе данных. Это будет один из вариантов реализации патерна data access object на языке java. 
 
	Теоретический проект 
Возьмём за пример приложение для Android. Контора, которая занимается предстраховыми осмотрами автомобилей, хочет автоматизировать процесс своих работников. Задача - обеспечить возможность собрать данные об автомобиле и передать их на обработку. 
Проектирование показало что у приложения будет 3 модуля. Авторизация, проведение осмотра и синхронизация. 
 
	Сущности 
Опишем сущности которыми мы будем оперировать в коде. Опираясь на ТЗ этого проекта и api сервера можно сделать несколько выводов. Будут существовать пользователи. Они будут получать с сервера шаблон сценария, по которому будет необходимо проводить осмотр. На основе этого информация будет собираться вместе в готовый осмотр и отправляться на сервер. 
 
	Data access 
Итак у нас есть пользователи, шаблоны и осмотры. Выделим для них 3 разных доступа. В данном случае это будут 3 интерфейса: 
UsersAccess 
ScenariosAccess 
InspectionsAccess 
Далее создадим наш data access object, который будет эти доступы предоставлять. Снова интерфейс: 
 DAO 
Теперь мы имеем все необходимые доступы, только пока они никаких данных не отдают и не изменяют. 
 
	Data models 
Создадим модели, которые будут описывать необходимые операции с сущностями. Начнём с пользователей. Что в данном проекте нам будет нужно с ними делать? В ТЗ сказано, что с одного устройства могут заходить разные пользователи. Значит нам нужно будет хранить список. Так же нам известно, что пользователи ничего не будут знать друг о друге. В таком случае можно создать модель: 
UsersModels 
Рассуждая подобным образом можно сделать вывод о том, что у нас будет ScenariosModels и InspectionsModels. Только эти будут оперировать уже несколькими сущностями. Шаблон будет состоять из типов шагов. А типы шагов из типов элементов. Нужно организовать возможность добавлять данные в базу. Получать шаблон по уникальному ключу, список типов шагов по ссылке на шаблон и список типов элементов по ссылке на шаг: 
ScenariosModels 
Готовый осмотр будет состоять из элементов, а элементы из данных. Нужно организовать возможность получения осмотра по ключу , так же списка осмотров черновиков и списка готовых осмотров. По аналогии для всех подсущностей осмотра: 
InspectionsModels 
Теперь передадим доступам их модели. И наш data access object готов. 
 
	Используем data access object 
У нас есть три модуля. Каждый должен получить доступ только к той области базы данных, которая ему необходима для выполнения задачи. 
При авторизации будет происходить работать только с пользователями. Поэтому этот модуль получит UsersAccess. Более того, так как необходимы операции только с одной сущностью можно урезать ответственность до модели Users. 
При прохождении осмотра, нужно будет опираться на шаблон, и на его основе составлять объект осмотра. Определять каким образом отображать шаги и элементы. Т.е. в данном случае необходим полный доступ ко всем сущностям шаблона и сущностям осмотра. Так что этому модулю можно передать ScenariosAccess вместе с InspectionsAccess. 
Во время синхронизации будет необходимо получать информацию о готовых осмотрах для передачи их на сервер. Со всеми элементами и прикреплёнными данными. В этот модуль стоит передать только InspectionsAccess. 
 
	Тестирование 
У нас уже описана логика по работе с бд. И мы даже используем её в модулях. Хотя пока нет реализации. Но мы уже можем написать тесты для всех доступов и моделей. Итак DAO должен успешно передавать доступы (не null). Точно так же для доступов. Они ничего не считают, а только передают данные. А вот для моделей можно написать тесты логики. Например модель Users должна изначально ничего не возвращать по ключу, затем после добавления объекта уже вернуть по ключу новый объект. Причём со всеми его полями в точно таком же виде, в котором он был добавлен в базу. По такому же принципу покрываем тестами все модели. 
 
	Implementation 
Теперь осталось выбрать с помощью чего мы будем реализовать наш data access object. Например можно использовать SQLite. Удобство такого метода в том, что мы сможем изменить реализацию или даже весь вид реализации, не затрагивая тех мест где оно используется. Совершенно безболезненно. Приведу пример такого перехода на практике... 
 
	Conclusion 
Такой подход к разработке позволяет строго разделять ответственности при работе с базой данных. Чётко видеть уровни доступа к данным и легко оперировать ими. И всё это возможно не опираясь на реализацию. Это же позволяет использовать этот подход вместе с TDD. А реализацию теперь можно будет настраивать более тонко, без изменений в других модулях. Так же как полностью заменить одну реализацию на другую. 