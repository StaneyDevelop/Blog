Введение
В этой части мы распишем как пользоваться библиотекой SQLiteDatabase, входящей в состав Android SDK. Как применить этот инструмент для построения своей базы данных. Настроить запись, чтение и обновление данных. Использовать для вывода информации из базы данных на экран.

Создание базы данных
За всю работу с базой данных у нас будет отвечать несколько классов. Создадим для них отдельный пакет .db. В нём создадим класс SQliteApi. Нам нужен будет безграничный доступ к базе данных из любого места в программе, поэтому сделаем его синглтоном.
За все операции с базой отвечает класс android.database.sqlite.SQLiteDatabase. Создадим в нашем классе SQliteApi поле private SQLiteDatabase sdb. Обращаться к нему будем только в методах, которые опишем далее. Теперь напишем функционал для создания самого файла базы данных. В этом нам поможет класс android.database.sqlite.SQLiteOpenHelper. Он может создать базу данных если её нет, предоставить возможность обновить базу данных если она уже существует и вернуть объект класса SQLiteDatabase, который мы будем использовать. Для этого ему нужен объект класса Context, так же личные данные спецально для самой базы данных, а именно название в виде строки и версия в виде целого числа. Эти значения должны быть константами во время выполнения. Поэтому мы добавим в класс параметр static private final String DB_NAME и присвоим ему значение соответствующее названию для нашей базы данных, например "wpreader". Ещё добавим параметр static private final int DB_VERSION и присвоим ему значение, которое будет означать данное конкретное состояние нашей базы данных. При изменении структуры нашей базы мы будем увеличивать это число (в данном случае для SQLite важно именно увеличивать, а не просто изменять).
Теперь создадим базу данных и получим экземпляр SQLiteDatabase. Для этого создадим метод public void createDB с одним входным параметром Context. В нём создадим экземпляр класса SQLiteOpenHelper через конструктор. Так как он является абстрактным, нужно реализовать два его абстрактных метода:
 - onCreate в нём будет описаны действия при создании базы данных
 - onUpgrade в нём будут описаны действия при обновлении базы данных, и он вызывается только в случае, когда существующая база имеет версию ниже, чем та которую мы использовали при инициализации SQLiteOpenHelper.
Обратите внимание на входные параметры onUpgrade. Нам дают возможность контролировать обновление базы данных, предоставляя версию текущей базы на устройстве int oldVersion и версию той которую мы хотим инициализировать int newVersion.
Далее можем вызвать у полученного экземпляра класса SQLiteOpenHelper метод getWritableDatabase и получить SQLiteDatabase.

Класс Application
Создадим несколько вспомогательных элементов для работы нашего приложения. В данный момент нам нужно определить первое вхождение в наше приложение для инициализации всего необходимого функционала работы с базой данных. Для этого мы можем создать класс наследуемый от android.app.Application. Создайте в корне главного пакета класс App, сделайте его наследником Application и переопределите метод onCreate. Внутри этого метода теперь мы будем описывать все необходимые операции которые должны будут произойти до того как любой из модулей нашего приложения заработает. Итак вызовем в этом методе createDB из SQliteApi. И подадим на вход Context полученный с помощью метода getApplicationContext. Теперь в любом месте нашего приложжения мы можем пользоваться функционалом SQliteApi, зная о том что база данных точно проинициализированна. Только для того чтобы это заработало нужно дополнительно указать в нашем AndroidManifest.xml в блоке application android:name=".App".
Если всё сделано правильно то при следующей сборке и запуске приложения на устройстве появится база данных. Это можно проверить по пути /data/data/{package}, тут должна появиться папка database, а в ней файл с именем которое мы указали при инициализации, т.е. SQliteApi.DB_NAME (обычно такие операции можно произвести при наличии root доступа на устройстве). Таким образом SQLiteDatabase в связке с SQLiteOpenHelper полностью отвечают за создание и хранение самой базы данных, занимается защитой доступа к базе, а так же предоставляет инструменты для взаимодействие с базой через приложение.

Запись в базу данных
Подробное описание работы SQL и работы реляционных баз данных выходит за рамки темы данной статьи, поэтому здесь будут описаны только необходимые для понимания общей картины моменты. SQLite использует систему строк и столбцов для хранения информации, группируя их в виде таблиц. Для каждой сущности принято выделять таблицу, а её свойства описывать в заголовках столбцов. Вернёмся к главной теме нашего приложения, а именно статьи на сайте WordPress. Применим метод описания сущностей под нашу задачу. Мы пока не знаем точно как будут выглядеть все свойства статьи, но можем описать некоторые. У статьи точно будет уникальный идентификатор, так же название и краткое описание. Представим себе такую таблицу.
Теперь создадим в коде необходимое описание этой сущности так, чтобы SQLiteDatabase смог им воспользоваться. Далее все создаваемые конструкции будут такими, исходя из факта о том что все свойства таблиц - это константы. Для этого в пакете .db создадим интерфейс Tables. В нём мы будем описывать все сущности, таблицы которых будет обрабатывать наша база данных.
Для описания сущностей "статей" создадим внутри interface Posts. Создадим параметр String TABLE_NAME в котором будет содержаться строка обозначающая название таблицы. Главное у этого параметра нужно использовать уникальное имя для каждой таблице в базе данных.
Свойства этой сущности мы опишем в другом внутреннем интерфейсе, для этого в Posts создадим interface Columns. Внутри Columns создадим параметры, для описания ранее придуманных свойств для сущности "статья". Данные параметры будут являться строковыми ключами по которым можно будет получить  доступ для чтения и\или записи конкретных данных в таблицу. Рекомендую не использовать одинаковые названия столбцов для разных таблиц. Например для соблюдения уникальности я инициализирую параметры таким образом String id = TABLE_NAME + "_" + "id".
После того как мы придумали название таблицы и название всех столбцов мы должны описать SQL запрос для создания таблицы. Обсуждать синтаксис подробно мы здесь не будем, но я опишу необходимые для создания таблицы моменты. Итак SQL запрос представляет из себя строку. Она должна состоять из префикса create table if not exists. Далее прибавляется название таблицы (между exists и названием таблицы должен быть пробел). После идут круглые скобки, в которых через запятую перечисляются названия столбцов с указанием типа. Мы будем использовать два типа, text - строковый тип и integer - целое число. Тут нужно обратить внимание на дополнительное описание для параметра, который мы хотим использовать для обозначения уникальности каждой записи в таблице (обычно по нему планируется получать данные о конкретной записи). В данном случае мы будем использовать для этого столбец id. Мы дополнительно укажем в описании типа этого параметра два ключевых слова, primary key - для указания того, что этот столбец уникален (в таблице не может быть более одной записи с одним и тем же значением этого параметра) и autoincrement - для указания того, что этому столбцу будет присваиваться значение само, исходя из существующих записей. В итоге присвоим собранную строку новому параметру String CREATE_TABLE в классе Posts.

Создаём таблицу
Вернёмся в класс SQliteApi, а точнее в реализацию абстрактных методов при создании экземпляра SQLiteOpenHelper в методе createDB. Опишем в методе onCreate то что должно происходить при создании базы данных. В нашем частном случае это будет создание таблиц. Создадим для этого метод private void createTables в классе SQliteApi с одним входным параметром SQLiteDatabase db. В нём мы используем полученый db для создания таблиц в базе. Для этого у db вызывается метод execSQL, на вход которому подаётся SQL запрос. Такой запрос мы сделали в классе Tables.Posts в параметре CREATE_TABLE. Далее обработаем метод onUpgrade. Важно понять, что использование этого метода происходит в такие моменты когда у баз данных разные версии, а это в совю очередь должно сигнализировать о том что в базе данных изменилась структура. Именно структура, т.е. количество и\или вид столбцов и\или таблиц, а не данные в базе. Для начала сделаем так, чтобы при изменении версии в базе данных таблицы просто удалялись и создавались заново по актуальной в данный момент схеме. Таким образом мы обойдём возможные проблемы с переносимостью, но при этом будем терять данные каждый раз когда будем изменять структуру данных. В связи с нашей задачей, второе для нас не актуально. Для стирания таблиц создадим метод private void clearTables в классе SQliteApi с одним входным параметром SQLiteDatabase db. В этом методе у db вызовем метод execSQL, а на вход ему подадим SQL запрос. Этот запрос мы составим в этом методе и он должен будет состоять из префикса drop table if exists. Далее прибавляется название таблицы (между exists и названием таблицы должен быть пробел). Так теперь старая база данных приравнивается к её отсутствию. Пропишем вызов метода clearTables и onCreate внутри onUpgrade(сначала удаляем все таблицы, потом создаём их заново, как при создании базы данных). Таким образом у нас получится самообновляемая система, которая защищена от ошибок связанных с неправильной настройкой базы данных. Как вы должны были заметить, для того чтобы изменения вступили в силу, а мы внесли изменения в структуру базы данных, нужно увеличить число отвечающее за версию базы данных.
