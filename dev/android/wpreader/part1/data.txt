Всем привет. В данном курсе мы будем писать клиент-серверное приложение для сайтов, работающих на CMS WordPress. Курс разбит на несколько частей. Эта часть будет посвящена основам.

Ведение
Здесь будут присутствовать советы по реализации фундаментальных областей построения приложения. Будут затронуты темы планирования архитектуры, создания логики и UI.

Необходимый уровень знаний
Данные уроки будут особенно интересны и полезны для начинающих, так как будет сделан упор на элементарные области связанные с программированием на Android. Такие как Activity, Fragment, ListView (или RecyclerView), Adapter и многие другие. Применяя эти знания можно будет быстрее начать использовать более сложные и новые инструменты. А пока стоит уточнить, что для усвоения данного материала необходимо, чтобы читатель уже обладал знаниями основ JavaSE (классы, интерфейсы, пакеты), навыками работы с Android Studio и Gradle (сборка проекта, настройка устройства для запуска и отладки приложений), иерархия файлов проекта Android Studio (исходный код, ресурсы)
Для начала нужно определиться с задачей. Обдумать варианты реализации решения. Глобальная задача подразумевает получение, хранение, обновление и вывод информации о статьях с сайта. Разделим эту задачу на части. Предположим, что у нас будет начальный экран, который будет демонстрировать превью статей.
Для решения мы создадим контейнер, который будет в себе содержать список, каждый элемент которого отображает данные о конкретной статье. В данной статье мы будем заниматься созданием собственно самого списка.

Начало работы
Создайте новый проект в Android Studio.
Приложение предназначено только для смартфонов и планшетов, поэтому смело выбирайте целевой девайс только Phone and Tablet. В шаблонах выберите Add No Activity.
По умолчанию Android Studio создаёт тему для приложения, которая включает в себя автоматическую установку Toolbar'а для всех экранов. Давайте изменим родителя AppTheme в файле styles.xml по пути /res с DarkActionBar на NoActionBar:
У нас не будет необходимости в стандартном Toolbar'е, т.к. в следующих уроках мы будем подключать свой.

Написание кода
Для запуска приложения необходимо создать точку входа - MainActivity. Для начала создания функционала связанного с UI создайте в главном пакете подпакет .ui. Наши activity мы будем хранить в пакете .ui.activities. Создайте класс MainActivity в пакете .ui.activities. Унаследуйте класс MainActivity от android.support.v7.app.AppCompatActivity
Для работы MainActivity необходимо создать его представление
Для этого в папке /res/layout создайте файл main_activity.xml. В AndroidStudio такой тип файлов в контекстном меню называется "Layout resource file". В файле обязательно должен быть указан главный контейнер этого представления. Укажите в качестве главного контейнера LinearLayout.
Далее необходимо внести изменения в класс MainActivity
Первым делом нужно переопределить метод onCreate в нашей Activity. В методе onCreate мы вызываем метод setContentView и передаем на вход id лейаута, который мы создали ранее. Таким образом мы установили содержимое для нашей Activity.
Для запуска приложения необходимо внести изменения и указать точку входа в AndroidManifest
Давайте пропишем наше Activity в Manifest-файле. В блоке intent-filter мы говорим системе, что MainActivity является точкой входа в приложение. Так же стоит указать заранее, что мы не хотим, чтобы приложение поворачивало экран при наклоне телефона. Сейчас нас интересует только портретная ориентация, поэтому в блок activity добавим строчку android:screenOrientation="portrait"
Теперь приложение готово к запуску
Сейчас мы реализовали один контейнер, который далее будет содержать в себе все необходимые для работы приложения элементы, а так же заниматься управлением их поведением. Позже для следующих задач в приложение будут добавлены ещё несколько Activity

Создание фрагмента
Фрагменты были созданы для того, чтобы отделить работу с контекстом приложения и работу с UI. Так же ими очень удобно управлять внутри одного Activity. Изменять представление экранов для разных задач, а так же комбинировать их и заменять одни на другие.
Нам необходимо создать один фрагмент для представления одного экрана, задача которого отображать список.
Необходимо сначала для всех фрагментов создать пакет .ui.fragments и внутри него создать класс MainFragment. Затем унаследовать его от класса android.support.v4.app.Fragment.
Для работы MainFragment необходимо создать его представление
По пути /res/layout создаём файл main_fragment.xml (таким же образом как мы создавали представление для MainActivity).
Далее необходимо внести изменения в класс MainFragment
Первым делом нужно переопределить метод onCreateView класса Fragment. В методе onCreateView необходимо установить представление для этого фрагмента и вернуть его в этом методе. Для этого мы создаём экземпляр класса View. Для его создания можно воспользоваться экземпляром класса LayoutInflater, который идёт входным параметром в методе onCreateView. У экземпляра класса LayoutInflater нужно вызвать метод inflate и передать на вход id лейоута, который мы создали специально для фрагмента
Где важно R.layout.main_fragment - это идентификатор лейоута который мы создали специально для фрагмента
container - экземпляр класса ViewGroup, который здесь используется для указания LayoutParams, а крайний входной элемент типа boolean (false) означает что мы не хотим чтобы наше представление не становилось дочерним элементом контейнера который мы подаём на вход в метод inflate
Теперь фрагмент имеет собственное представление и готов к использованию

Подключаем фрагмент к Activity
Всеми фрагментами внутри activity управляет FragmentManager
Для отображения фрагмента необходимо создать контейнер в представлении MainActivity
В R.layout.main_activity внутри главного контейнера создать контейнер класса FrameLayout (самый простой контейнер). Указать у него id для того, чтобы его можно было идентифицировать и использовать. Желательно в размерах ширины и высоты указать match_parent
Нам нужно добавить MainFragment в MainActivity
Для этого нужно получить экземпляр класса FragmentManager. Так как мы используем support библиотеку, нам необходимо вызвать у MainActivity метод getSupportFragmentManager(). Создайте в классе MainActivity метод private void init(), в котором мы пропишем все необходимые действия для добавления фрагмента. Далее внутри метода init вызвать несколько методов цепочкой:
getSupportFragmentManager() - возвращает экземпляр класса FragmentManager, у которого можно вызвать beginTransaction()
beginTransaction() - возвращает экземпляр класса FragmentTransaction, у которого можно вызвать add(). Этим методом мы указываем на создание транзакции, в которой обозначим, что будем делать.
add() - означает добавление нового фрагмента. Для этого необходим идентификатор контейнера и экземпляр класса фрагмента. Указываем входными параметрами, что хотим добавить фрагмент в контейнер. Этот метод возвращает экземпляр класса FragmentTransaction, у которого можно вызвать commit()
commit() - указываем, что хотим применить операции. Конкретно в нашем случае добавить фрагмент в список фрагментов MainActivity
Добавьте вызов нашего нового метода init() внутри метода onCreate сразу после setContentView
Приложение готово к запуску, и теперь главным представлением вашего приложения будет представление MainFragment
MainActivity помимо своего представления, включает в себя MainFragment, который реализует свою часть представления экрана
Данная часть описывает процесс создания каркаса, на котором строится начало практически любого проекта. Важно понимать, что это не единственно верное решение, а лишь один из способов достижения цели. Теперь необходимо перейти к реализации работы со списком. Как конкретно будет реализовано решение этой задачи, мы опишем далее более детально.

Устанавливаем RecyclerView во фрагмент
Виджет RecyclerView служит для реализации представления данных в виде списка. Конкретно мы его будем использовать для вывода списка состоящего из краткого содержания статей с wordpress сайта. Он имеет ряд преимуществ перед ListView, который ранее использовался для данной задачи, и для его подключения необходимо подключить библиотеку com.android.support:recyclerview-v7
Добавьте зависимость compile 'com.android.support:recyclerview-v7:24.0.0' в app/build.gradle для подключения RecyclerView.
Магия gradle
Любые изменения в файлах gradle вступят в силу только после того как произойдёт синхронизация gradle. Описание этих процессов выходит за рамки данной статьи. Главное в этом деле запомнить простое правило. После любых изменений в файлах gradle при работе в Android Studio нажимать на кнопку "Sync project with Gradle files"
Добавьте RecyclerView в layout-файл класса MainFragment. Для этого в файле /res/layout/main_fragment.xml, внутри главного контейнера создайте виджет android.support.v7.widget.RecyclerView (в превью должно появится представление RecyclerView в виде списка Items, если всё сделано верно). Укажите id у RecyclerView для того, чтобы его можно было идентифицировать в классе фрагмента. В размерах ширины и высоты нашего RecyclerView указать match_parent(растянуться максимально по ширине и высоте родителя)
Теперь, для того, чтобы использовать RecyclerView, необходимо добавить код для работы с RecyclerView в MainFragment. В классе MainFragment создайте поле private RecyclerView list_posts. Давайте проинициализируем наш RecyclerView во фрагменте:
Представление MainFragment включает в себя список
Пока мы сделали всё, что было можно сделать с RecyclerView. Теперь нужно создать Adapter и подключить к нашему list_posts.
Стиль написания кода
До этого момента для написания кода использовался стиль CamelCase. Сейчас для названия переменной RecyclerView list_posts я использовал правило написания, при котором все переменные в коде, которые представляют ресурсы (например элементы xml разметки) именуются так же, как те сущности, которые они представляют. Таким образом, читая код, можно визуально определить, к чему относится конкретная переменная без контекста. Важно понимать, что данный метод не является единственно верным и обязательным к применению.

Создаём Adapter
Adapter нужен для управления тем какие элементы у списка будут, сколько их будет, и как именно они будут отображаться.
Почему Adapter обязательно нужен
Очень важно осознать необходимость данного инструмента (хотя это не обязательно единственный способ решения) на ранних этапах разработки. И так же важно понять как работает адаптер. Попробую описать неочевидную проблему через аналогию. Если перед вами поставили задачу - "должны проехать несколько машин". Задача элементарна до безобразия. Особенно если представлять это, как задачу которую нужно решить в реальной жизни, руками и с реальными машинами. Каким-то образом можно получить 5(а количество может быть любым) машин(любой марки, цвета и остальных составляющих) и провезти их в один ряд. Очень простой пример.
А теперь обратимся к списку в программировании. Нельзя просто сказать "нарисуй мне список". Список не может по умолчанию работать с любыми типами данных (желаемым для нас образом). Нужно обязательно указать сколько элементов будет, как они будут выглядеть и их поведение.
Итак отображение списка можно реализовать так:
Или например так:
Адаптер занимается этой задачей. Внутри него мы можем точно указать всё необходимое, чтобы список отобразился таким, как нам это необходимо. А важно то, что указать "как нам необходимо" нужно обязательно и в любом случае. Даже если реализация отображения списка элементарная.
Необходимо для всех адаптеров создать пакет .ui.adapters. Внутри создать класс PostsAdapter.
Привяжем наш адаптер к контексту, это нам понадобится позднее. Для этого создадим в классе PostsAdapter поле private Context context. И реализуем public конструктор PostsAdapter с одним входным параметром - объект класса Context. Внутри конструктора присвоим входной объект нашему context
Мы уже имеем некоторое представление о том что делает Adapter. Он указывает RecyclerView, что нужно отобразить и каким образом. Для этого ему нужны данные. Поэтому внутри класса PostsAdapter необходимо создать поле с данными. Для первого запуска мы сделаем поле private List data для заглушки (позже мы переделаем это для работы с данными из SQLite базы данных) и попробуем вывести список из ранее заданных строк
Теперь как отображать данные. За это отвечает класс RecyclerView.ViewHolder. Наследуясь от него мы сможем создать свой класс, в которым опишем, как будет выглядеть каждый элемент нашего списка. Внутри класса PostsAdapter нужно создать public class PostHolder и унаследовать его от класса RecyclerView.ViewHolder. Далее реализовать конструктор класса PostHolder, в котором указать входным параметром View v . И в первой строчке конструктора вызвать super(v)
PostHolder готов к использованию. Теперь укажем внутри него то, что будет отображать наш Adapter в каждом элементе RecyclerView.
Первым делом создадим представление элемента
По пути /res/layout создаём файл post.xml. В этом файле, внутри главного контейнера создать TextView виджет. Указать у него id. Желательно в размерах ширины и высоты указать wrap_content. Сейчас мы хотим вывести вертикальный список с элементами, которые растягиваются по всей ширине. Необходимо проверить чтобы у главного контейнера размер высоты стоял wrap_content (иначе каждый элемент растянется по всей высоте экрана)
Далее добавим изменения в класс PostHolder. Создадим внутри поле public TextView text. Это поле указывает на виджет, который будет использоваться для вывода некоторого текста в элементах нашего списка. Далее внутри конструктора класса PostHolder инициализируем наш text с помощью вызова метода v.findViewById
Теперь PostHolder настроен и пора использовать его в нашем PostsAdapter . Унаследуем PostsAdapter от RecyclerView.Adapter Нужно обязательно реализовать три метода
getItemCount - это метод в который нужно вернуть количество элементов, которое адаптер будет готов отрисовать. Сейчас у нас простая реализация и мы хотим вывести все элементы которые содержаться в List data. Поэтому в методе getItemCount мы вернём data.size(). И добавим перед return проверку. if(data == null) пусть при таком условии getItemCount вернёт 0. Таким образом мы избежим NullPointerException и правильно обработаем ситуацию, при которой данных нет.
onCreateViewHolder - в этом методе нужно создать холдер и вернуть его. Именно этот холдер будет указывать, что отображать в каждом элементе списка
У нас есть реализация холдера - PostHolder. И onCreateViewHolder должен быть настроен для того, чтобы мы вернули именно PostHolder. А чтобы создать PostHolder нам необходим экземпляр класса View, и для его создания мы воспользуемся методом который применяли при создании фрагмента
Получим View с помощью LayoutInflater и его метода inflate. Только LayoutInflater нам нужно будет создать самим, используя статический метод from. Для этого метода необходим экземпляр класса Context. Используем объект context класса PostsAdapter
Получение View с помощью inflate было описано ранее. Теперь на вход этому методу необходимо подать идентификатор нашего представления R.layout.post, объект класса ViewGroup, входящий параметр метода onCreateViewHolder, и false. И вернуть в конце метода onCreateViewHolder объект класса PostHolder. То есть использовать полученный View vи вызвать new PostHolder(v)
onBindViewHolder - этот метод будет вызываться каждый раз, когда адаптеру потребуется отрисовать новый элемент. На входе получаем готовый объект холдера (в нашем конкретном случае это PostHolder) - holder и номер элемента - position. Используя эти два параметра можно обозначить логику отрисовки элементов. Так сейчас мы укажем, что у каждого PostHolder будет применяться текст из data в элемент text. Для этого внутри метода onBindViewHolder мы укажем holder.text.setText(data.get(position)). Что значит - каждому n элементу holder.text отрисовать текст из n элемента data
AndroidStudio должна помочь реализовать эти методы автоматически при наследовании от RecyclerView.Adapter И осталось создать систему при которой будет возможно изменять данные у адаптера. То есть List data. Для этого создаём в классе PostsAdapter метод public void swapData(List d). Внутри этого метода присваиваем объект d к data.
MainFragment в своей логике использует функционал адаптера PostsAdapter
PostsAdapter готов к использованию

Подключаем PostsAdapter к RecyclerView в MainFragment
Создадим в классе MainFragment поле private PostsAdapter adapter и метод private void init без входных параметров. Добавим вызов этого метода сразу после вызова метода initViews внутри метода onCreateView. Теперь внутри метода init можно работать с виджетами и быть уверенными в том что они точно проинициализированы.
Реализуем PostsAdapter внутри MainFragment и подключим его к list_posts
Внутри метода init инициализируем PostsAdapter и входящим параметром в конструктор PostsAdapter передаём контекст используя метод getActivity. Далее нужно добавить настройку к нашему list_posts. В RecyclerView есть сущность которая руководит тем каким образом элементы будут идти друг за другом. Нам необходима самая простая реализация выводящая элементы по порядку в один столбец. Для этого мы воспользуемся классом LinearLayoutManager. Создадим экземпляр этого класса. В конструктор LinearLayoutManager необходимо подать контекст и мы его можем получить используя метод getActivity. И укажем нашему list_posts это менеджер с помощью метода setLayoutManager.
Пришло время установить PostsAdapter adapterк RecyclerView list_posts. Это можно сделать вызвав метод setAdapter у list_posts
Теперь адаптер и RecyclerView работают вместе. Но RecyclerView никаких данных пока не отображает. Для того чтобы создать эти данные мы следующей строкой после list_posts.setAdapter(adapter) создадим объект класса List и проинициализируем его. Добавим в него несколько элементов и укажем адаптеру, что мы хотим использовать эти данные. Это можно сделать с помощью метода swapData, который мы специально для этого сделали в классе PostsAdapter
MainFragment использует функционал адаптера PostsAdapter для формирования представления элементов списка в своём представлении
Теперь у нас есть список, RecyclerView list_posts, который выводит данные из List data таким образом, который мы реализовали в классе PostsAdapter
Пример запущенного приложения на устройстве Nexus5 Android 6.0.1

Итак у нас получилось создать функционал для работы со списком. Мы создали MainActivity и MainFragment, связывающие логику и представление. MainActivity пока использует MainFragment как своё основное представление. Далее, чтобы работать над реализацией списка нам не нужно возвращаться к MainActivity. MainFragment реализует своё представление в виде списка. Далее для управления поведением этого списка нам не нужно возвращаться к MainFragment, так как эту задачу взял на себя PostsAdapter . PostsAdapter используется в связке с PostHolder для реализации логики того, как будет отображаться список. В следующей части мы реализуем хранение, чтение, запись данных о статьях с помощью библиотеки SQLiteDatabase входящей в состав AndroidSDK. И используем этот навык для передачи данных в PostsAdapter для последующей отрисовки в списке.