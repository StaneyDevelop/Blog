<span style="font-size: 12pt; color: #000000;">Всем привет. В данном курсе мы будем писать клиент-серверное приложение для сайтов, работающих на <strong>WordPress</strong>. Курс разбит на несколько частей. После прохождения этого курса мы станем обладать навыками:</span>
<ul>
 	<span style="font-size: 12pt; color: #009688;"><li>создание разных экранов для разных задач, переключение и взаимодействие между ними</li>
 	<li>создание различных элементов UI для взаимодействия с пользователем</li>
 	<li>работа со стилями для настройки внешнего вида приложения</li>
 	<li>получение данных по сети</li>
 	<li>создание базы данных, запись, чтение и изменение данных</li></span>
</ul>
<span style="font-size: 12pt; color: #000000;">Эта часть будет посвящена основам. Здесь будут присутствовать советы по реализации фундаментальных частей приложения. Будут затронуты темы планирования архитектуры, создания логики и UI.</span>

<span style="font-size: 14pt; color: #000000;"><em>Необходимый уровень знаний</em></span>
<span style="font-size: 12pt; color: #000000;">Данные уроки будут особенно интересны и полезны для начинающих, так как будет сделан упор на элементарные области связанные с программированием на <strong>Android</strong>. Применяя эти знания можно будет быстрее начать использовать более сложные и новые инструменты. Стоит уточнить, что для усвоения данного материала необходимо, чтобы читатель уже обладал знаниями основ <strong>JavaSE</strong> <span style="font-size: 10pt; color: #ff5722;">(классы, интерфейсы, пакеты)</span>, навыками работы с <strong>Android Studio</strong> и <strong>Gradle</strong> <span style="font-size: 10pt; color: #ff5722;">(сборка проекта, настройка устройства для запуска и отладки приложений)</span>, иерархия файлов проекта <strong>Android Studio</strong> <span style="font-size: 10pt; color: #ff5722;">(исходный код, ресурсы)</span>.</span>

<span style="font-size: 12pt; color: #000000;">Для начала нужно определиться с задачей. Обдумать варианты реализации решения. Итак мы должны получить данные с сайта по сети, сохранить их и использовать их чтобы вывести на экран и показать пользователю. Четыре шага.</span>
<img class="size-medium wp-image-104 aligncenter" src="https://standev.files.wordpress.com/2016/11/wpreader-prt1-bgnwrk-normalpng.png?w=300" alt="wpreader-prt1-bgnwrk-normalpng" width="300" height="300" />
<span style="font-size: 12pt; color: #000000;">Это очень гибкая система. Достаточно реализовать эти шаги для возможности работы приложения в разных условиях.</span>
<img class="aligncenter size-medium wp-image-105" src="https://standev.files.wordpress.com/2016/11/wpreader-prt1-bgnwrk-issue.png?w=298" alt="wpreader-prt1-bgnwrk-issue" width="298" height="300" />
<span style="font-size: 12pt; color: #000000;">В итоге мы должны научиться реализовать каждый из модулей. Разделим на подзадачи. Предположим, что у нас будет начальный экран, который будет демонстрировать превью статей. Для решения мы создадим контейнер, который будет в себе содержать список, каждый элемент которого отображает данные о конкретной статье. В данной статье мы будем заниматься созданием этого списка.</span>
<img class="aligncenter size-medium wp-image-110" src="https://standev.files.wordpress.com/2016/11/wpreader-prt2-preview.png?w=155" alt="wpreader-prt2-preview" width="155" height="300" />
<h3>Начало работы</h3>
Создайте новый проект в Android Studio.
Приложение предназначено только для смартфонов и планшетов, поэтому смело выбирайте целевой девайс только Phone and Tablet. В шаблонах выберите Add No Activity.
По умолчанию Android Studio создаёт тему для приложения, которая включает в себя автоматическую установку Toolbar'а для всех экранов. Давайте изменим родителя AppTheme в файле styles.xml по пути /res с DarkActionBar на NoActionBar:
У нас не будет необходимости в стандартном Toolbar'е, т.к. в следующих уроках мы будем подключать свой.

Написание кода
Для запуска приложения необходимо создать точку входа - MainActivity. Для начала создания функционала связанного с UI создайте в главном пакете подпакет .ui. Наши activity мы будем хранить в пакете .ui.activities. Создайте класс MainActivity в пакете .ui.activities. Унаследуйте класс MainActivity от android.support.v7.app.AppCompatActivity
Для работы MainActivity необходимо создать его представление
Для этого в папке /res/layout создайте файл main_activity.xml. В AndroidStudio такой тип файлов в контекстном меню называется "Layout resource file". В файле обязательно должен быть указан главный контейнер этого представления. Укажите в качестве главного контейнера LinearLayout.
Далее необходимо внести изменения в класс MainActivity
Первым делом нужно переопределить метод onCreate в нашей Activity. В методе onCreate мы вызываем метод setContentView и передаем на вход id лейаута, который мы создали ранее. Таким образом мы установили содержимое для нашей Activity.
Для запуска приложения необходимо внести изменения и указать точку входа в AndroidManifest
Давайте пропишем наше Activity в Manifest-файле. В блоке intent-filter мы говорим системе, что MainActivity является точкой входа в приложение. Так же стоит указать заранее, что мы не хотим, чтобы приложение поворачивало экран при наклоне телефона. Сейчас нас интересует только портретная ориентация, поэтому в блок activity добавим строчку android:screenOrientation="portrait"
Теперь приложение готово к запуску
Сейчас мы реализовали один контейнер, который далее будет содержать в себе все необходимые для работы приложения элементы, а так же заниматься управлением их поведением. Позже для следующих задач в приложение будут добавлены ещё несколько Activity

Создание фрагмента
Фрагменты были созданы для того, чтобы отделить работу с контекстом приложения и работу с UI. Так же ими очень удобно управлять внутри одного Activity. Изменять представление экранов для разных задач, а так же комбинировать их и заменять одни на другие.
Нам необходимо создать один фрагмент для представления одного экрана, задача которого отображать список.
Необходимо сначала для всех фрагментов создать пакет .ui.fragments и внутри него создать класс MainFragment. Затем унаследовать его от класса android.support.v4.app.Fragment.
Для работы MainFragment необходимо создать его представление
По пути /res/layout создаём файл main_fragment.xml (таким же образом как мы создавали представление для MainActivity).
Далее необходимо внести изменения в класс MainFragment
Первым делом нужно переопределить метод onCreateView класса Fragment. В методе onCreateView необходимо установить представление для этого фрагмента и вернуть его в этом методе. Для этого мы создаём экземпляр класса View. Для его создания можно воспользоваться экземпляром класса LayoutInflater, который идёт входным параметром в методе onCreateView. У экземпляра класса LayoutInflater нужно вызвать метод inflate и передать на вход id лейоута, который мы создали специально для фрагмента
Где важно R.layout.main_fragment - это идентификатор лейоута который мы создали специально для фрагмента
container - экземпляр класса ViewGroup, который здесь используется для указания LayoutParams, а крайний входной элемент типа boolean (false) означает что мы не хотим чтобы наше представление не становилось дочерним элементом контейнера который мы подаём на вход в метод inflate
Теперь фрагмент имеет собственное представление и готов к использованию

Подключаем фрагмент к Activity
Всеми фрагментами внутри activity управляет FragmentManager
Для отображения фрагмента необходимо создать контейнер в представлении MainActivity
В R.layout.main_activity внутри главного контейнера создать контейнер класса FrameLayout (самый простой контейнер). Указать у него id для того, чтобы его можно было идентифицировать и использовать. Желательно в размерах ширины и высоты указать match_parent
Нам нужно добавить MainFragment в MainActivity
Для этого нужно получить экземпляр класса FragmentManager. Так как мы используем support библиотеку, нам необходимо вызвать у MainActivity метод getSupportFragmentManager(). Создайте в классе MainActivity метод private void init(), в котором мы пропишем все необходимые действия для добавления фрагмента. Далее внутри метода init вызвать несколько методов цепочкой:
getSupportFragmentManager() - возвращает экземпляр класса FragmentManager, у которого можно вызвать beginTransaction()
beginTransaction() - возвращает экземпляр класса FragmentTransaction, у которого можно вызвать add(). Этим методом мы указываем на создание транзакции, в которой обозначим, что будем делать.
add() - означает добавление нового фрагмента. Для этого необходим идентификатор контейнера и экземпляр класса фрагмента. Указываем входными параметрами, что хотим добавить фрагмент в контейнер. Этот метод возвращает экземпляр класса FragmentTransaction, у которого можно вызвать commit()
commit() - указываем, что хотим применить операции. Конкретно в нашем случае добавить фрагмент в список фрагментов MainActivity
Добавьте вызов нашего нового метода init() внутри метода onCreate сразу после setContentView
Приложение готово к запуску, и теперь главным представлением вашего приложения будет представление MainFragment
MainActivity помимо своего представления, включает в себя MainFragment, который реализует свою часть представления экрана
Данная часть описывает процесс создания каркаса, на котором строится начало практически любого проекта. Важно понимать, что это не единственно верное решение, а лишь один из способов достижения цели. Теперь необходимо перейти к реализации работы со списком. Как конкретно будет реализовано решение этой задачи, мы опишем далее более детально.

Итак у нас получилось создать функционал для работы со списком. Мы создали MainActivity и MainFragment, связывающие логику и представление. MainActivity пока использует MainFragment как своё основное представление. Далее, чтобы работать над реализацией списка нам не нужно возвращаться к MainActivity. MainFragment реализует своё представление в виде списка. Далее для управления поведением этого списка нам не нужно возвращаться к MainFragment, так как эту задачу взял на себя PostsAdapter. PostsAdapter используется в связке с PostHolder для реализации логики того, как будет отображаться список. В следующей части мы реализуем хранение, чтение, запись данных о статьях с помощью библиотеки SQLiteDatabase входящей в состав AndroidSDK. И используем этот навык для передачи данных в PostsAdapter для последующей отрисовки в списке.