Создаём Adapter
Adapter нужен для управления тем какие элементы у списка будут, сколько их будет, и как именно они будут отображаться.
Почему Adapter обязательно нужен
Очень важно осознать необходимость данного инструмента (хотя это не обязательно единственный способ решения) на ранних этапах разработки. И так же важно понять как работает адаптер. Попробую описать неочевидную проблему через аналогию. Если перед вами поставили задачу - "должны проехать несколько машин". Задача элементарна до безобразия. Особенно если представлять это, как задачу которую нужно решить в реальной жизни, руками и с реальными машинами. Каким-то образом можно получить 5(а количество может быть любым) машин(любой марки, цвета и остальных составляющих) и провезти их в один ряд. Очень простой пример.
А теперь обратимся к списку в программировании. Нельзя просто сказать "нарисуй мне список". Список не может по умолчанию работать с любыми типами данных (желаемым для нас образом). Нужно обязательно указать сколько элементов будет, как они будут выглядеть и их поведение.
Итак отображение списка можно реализовать так:
Или например так:
Адаптер занимается этой задачей. Внутри него мы можем точно указать всё необходимое, чтобы список отобразился таким, как нам это необходимо. А важно то, что указать "как нам необходимо" нужно обязательно и в любом случае. Даже если реализация отображения списка элементарная.
Необходимо для всех адаптеров создать пакет .ui.adapters. Внутри создать класс PostsAdapter.
Привяжем наш адаптер к контексту, это нам понадобится позднее. Для этого создадим в классе PostsAdapter поле private Context context. И реализуем public конструктор PostsAdapter с одним входным параметром - объект класса Context. Внутри конструктора присвоим входной объект нашему context
Мы уже имеем некоторое представление о том что делает Adapter. Он указывает RecyclerView, что нужно отобразить и каким образом. Для этого ему нужны данные. Поэтому внутри класса PostsAdapter необходимо создать поле с данными. Для первого запуска мы сделаем поле private List data для заглушки (позже мы переделаем это для работы с данными из SQLite базы данных) и попробуем вывести список из ранее заданных строк
Теперь как отображать данные. За это отвечает класс RecyclerView.ViewHolder. Наследуясь от него мы сможем создать свой класс, в которым опишем, как будет выглядеть каждый элемент нашего списка. Внутри класса PostsAdapter нужно создать public class PostHolder и унаследовать его от класса RecyclerView.ViewHolder. Далее реализовать конструктор класса PostHolder, в котором указать входным параметром View v . И в первой строчке конструктора вызвать super(v)
PostHolder готов к использованию. Теперь укажем внутри него то, что будет отображать наш Adapter в каждом элементе RecyclerView.
Первым делом создадим представление элемента
По пути /res/layout создаём файл post.xml. В этом файле, внутри главного контейнера создать TextView виджет. Указать у него id. Желательно в размерах ширины и высоты указать wrap_content. Сейчас мы хотим вывести вертикальный список с элементами, которые растягиваются по всей ширине. Необходимо проверить чтобы у главного контейнера размер высоты стоял wrap_content (иначе каждый элемент растянется по всей высоте экрана)
Далее добавим изменения в класс PostHolder. Создадим внутри поле public TextView text. Это поле указывает на виджет, который будет использоваться для вывода некоторого текста в элементах нашего списка. Далее внутри конструктора класса PostHolder инициализируем наш text с помощью вызова метода v.findViewById
Теперь PostHolder настроен и пора использовать его в нашем PostsAdapter . Унаследуем PostsAdapter от RecyclerView.Adapter Нужно обязательно реализовать три метода
getItemCount - это метод в который нужно вернуть количество элементов, которое адаптер будет готов отрисовать. Сейчас у нас простая реализация и мы хотим вывести все элементы которые содержаться в List data. Поэтому в методе getItemCount мы вернём data.size(). И добавим перед return проверку. if(data == null) пусть при таком условии getItemCount вернёт 0. Таким образом мы избежим NullPointerException и правильно обработаем ситуацию, при которой данных нет.
onCreateViewHolder - в этом методе нужно создать холдер и вернуть его. Именно этот холдер будет указывать, что отображать в каждом элементе списка
У нас есть реализация холдера - PostHolder. И onCreateViewHolder должен быть настроен для того, чтобы мы вернули именно PostHolder. А чтобы создать PostHolder нам необходим экземпляр класса View, и для его создания мы воспользуемся методом который применяли при создании фрагмента
Получим View с помощью LayoutInflater и его метода inflate. Только LayoutInflater нам нужно будет создать самим, используя статический метод from. Для этого метода необходим экземпляр класса Context. Используем объект context класса PostsAdapter
Получение View с помощью inflate было описано ранее. Теперь на вход этому методу необходимо подать идентификатор нашего представления R.layout.post, объект класса ViewGroup, входящий параметр метода onCreateViewHolder, и false. И вернуть в конце метода onCreateViewHolder объект класса PostHolder. То есть использовать полученный View vи вызвать new PostHolder(v)
onBindViewHolder - этот метод будет вызываться каждый раз, когда адаптеру потребуется отрисовать новый элемент. На входе получаем готовый объект холдера (в нашем конкретном случае это PostHolder) - holder и номер элемента - position. Используя эти два параметра можно обозначить логику отрисовки элементов. Так сейчас мы укажем, что у каждого PostHolder будет применяться текст из data в элемент text. Для этого внутри метода onBindViewHolder мы укажем holder.text.setText(data.get(position)). Что значит - каждому n элементу holder.text отрисовать текст из n элемента data
AndroidStudio должна помочь реализовать эти методы автоматически при наследовании от RecyclerView.Adapter И осталось создать систему при которой будет возможно изменять данные у адаптера. То есть List data. Для этого создаём в классе PostsAdapter метод public void swapData(List d). Внутри этого метода присваиваем объект d к data.
MainFragment в своей логике использует функционал адаптера PostsAdapter
PostsAdapter готов к использованию