Создаём адаптер
Адаптер нужен для управления тем, какие элементы у списка будут, сколько их будет, и как именно они будут отображаться. В нём мы точно укажем всё нужное, чтобы список отобразился таким, как нам это необходимо.
Создадим для всех адаптеров пакет .ui.adapters, а внутри класс PostsAdapter. Привяжем наш адаптер к контексту, это нам понадобится позднее. Cоздадим в классе PostsAdapter поле private Context context. И реализуем public конструктор PostsAdapter с одним входным параметром - объект класса Context. Внутри конструктора присвоим входной объект нашему context. Чтобы указать, что нужно отобразить, адаптеру нужны данные. Поэтому внутри класса PostsAdapter создадим поле с данными private List<String> data (мы будем выводить список из ранее заданных строк).
За то как отображать данные отвечает класс RecyclerView.ViewHolder. Наследуясь от него, мы сможем создать свой класс, в которым опишем, как будет выглядеть каждый элемент нашего списка. Внутри класса PostsAdapter нужно создать public class PostHolder, унаследовать его от класса RecyclerView.ViewHolder и переопределить конструктор. Теперь укажем внутри него то, что будет отображать наш адаптер в каждом элементе RecyclerView. Создадим представление элемента post.xml по пути /res/layout. Внутри главного контейнера создадим TextView. Сейчас мы хотим создать представление элементов, которые растягиваются по всей ширине.
Добавим изменения в класс PostHolder. Создадим внутри поле public TextView text. Это поле указывает на виджет, который будет использоваться для вывода некоторого текста в элементах нашего списка. Далее внутри конструктора класса PostHolder инициализируем text с помощью findViewById. Теперь PostHolder настроен и пора использовать его в нашем PostsAdapter. Унаследуем PostsAdapter от RecyclerView.Adapter.
Далее реализуем три метода:
- getItemCount - в нём нужно вернуть количество элементов, которое адаптер будет готов отрисовать
- onCreateViewHolder - в нём нужно создать холдер и вернуть его
- onBindViewHolder - будет вызываться каждый раз, когда адаптеру потребуется отрисовать новый элемент
Сейчас у нас простая реализация и мы хотим вывести все строки которые содержаться в data. В getItemCount вернём data.size(). Добавим перед return проверку if(data == null). Пусть при таком условии getItemCount вернёт 0. А onCreateViewHolder должен быть настроен для того, чтобы мы вернули PostHolder. Чтобы создать PostHolder нужен экземпляр класса View, и для его создания мы воспользуемся методом, который применяли при создании фрагмента. Только LayoutInflater нам нужно будет создать самим, используя статический метод from. Для этого метода необходим экземпляр класса Context. Используем объект context класса PostsAdapter. Теперь на вход этому методу подадим идентификатор представления холдера R.layout.post, объект класса ViewGroup, входящий параметр метода onCreateViewHolder, и false. И вернуть в конце onCreateViewHolder объект класса PostHolder. На входе onBindViewHolder получаем объект холдера (в нашем конкретном случае это PostHolder) и номер элемента - position. Используя эти два параметра можно обозначить логику отрисовки элементов. Для этого внутри onBindViewHolder вызываем holder.text.setText(data.get(position)). То есть каждому position элементу holder.text отрисовать текст из position элемента data.
И осталось создать систему при которой будет возможно изменять данные у адаптера. То есть data. Для этого создаём в классе PostsAdapter метод public void swapData(List<String> d). Внутри этого метода присваиваем объект d к data.